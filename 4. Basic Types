4.1 Numbers

Integer
1.ğŸŒŸ
fn main() {
    let x: i32 = 5;
    let y: u32 = 5;

    let z = x as u32 + y;
    println!("{}", z);
}

2.ğŸŒŸ

// Fill the blank
fn main() {
    let v: u16 = 38_u8 as u16;

    println!("Success!");
}

3.ğŸŒŸğŸŒŸğŸŒŸ

// Fill the blank
fn main() {
    let v: u16 = 38_u8 as u16;

    println!("Success!");
}

4.ğŸŒŸğŸŒŸ
fn main() {
    let max_i8 = i8::MAX;
    let max_u8 = u8::MAX;

    assert_eq!(max_i8, 127);
    assert_eq!(max_u8, 255);

    println!("Success!");
}

5.ğŸŒŸğŸŒŸ

fn main() {
    let a = 10;
    let b = 3;

    assert_eq!(a + b, 13);
    assert_eq!(a - b, 7);
    assert_eq!(a * b, 30);
    assert_eq!(a / b, 3);
    assert_eq!(a % b, 1);

    println!("Success!");
}

6.ğŸŒŸğŸŒŸ
fn main() {
    let a = true;
    let b = false;

    assert!(a && !b);
    assert!(a || b);
    assert!(!b);

    println!("Success!");
}

7.ğŸŒŸ
fn main() {
    let x: f64 = 1.0;

    assert_eq!(x + 0.1, 1.1);

    println!("Success!");
}

8.ğŸŒŸğŸŒŸ Make it work in two distinct ways
fn main() {
    let a = 0.1f32;
    let b = 0.2f32;

    assert!((a + b - 0.3).abs() < f32::EPSILON);

    println!("Success!");
}

Range
9.ğŸŒŸğŸŒŸ Two goals: 1. Modify assert! to make it work 2. Make println! output list of numbers between 97 and 122
fn main() {
    for c in 'a'..('z' as u8 + 1) as char {
        print!("{}", c);
    }
    println!();
}

10.ğŸŒŸğŸŒŸ

fn main() {
    for i in 1..5 {
        print!("{} ", i);
    }
    println!();

    for j in 1..=5 {
        print!("{} ", j);
    }
    println!();
}

Computations
11.ğŸŒŸ
fn main() {
    let a = 5;
    let b = 3;

    // ĞÑ€Ğ¸Ñ„Ğ¼ĞµÑ‚Ğ¸ĞºĞ°
    assert_eq!(a + b, 8);
    assert_eq!(a - b, 2);
    assert_eq!(a * b, 15);
    assert_eq!(a / b, 1);
    assert_eq!(a % b, 2);

    // Ğ›Ğ¾Ğ³Ñ–ĞºĞ°
    assert!(a > b && b < a);
    assert!(a == 5 || b == 0);
    assert!(!(a < b));

    println!("Success!");
}


4.2 Char, Bool and Unit
Char
1.ğŸŒŸ

use std::mem::size_of_val;

fn main() {
    let c1 = 'a';
    let c2 = 'ä¸­';

    assert_eq!(size_of_val(&c1), 4);
    assert_eq!(size_of_val(&c2), 4);

    println!("Success!");
}

2.ğŸŒŸ

fn main() {
    let c1 = 'ä¸­'; // Ğ¢ĞµĞ¿ĞµÑ€ Ñ†Ğµ char
    print_char(c1);
}

fn print_char(c: char) {
    println!("{}", c);
}

Bool

3.ğŸŒŸ
fn main() {
    let t = true;
    let f = false;

    assert_eq!(t && f, false);
    assert_eq!(t || f, true);
    assert_eq!(!t, false);

    println!("Success!");
}

4.ğŸŒŸ
fn main() {
    let v = implicitly_ret_unit();
    assert_eq!(v, ()); // unit

    println!("Success!");
}

fn implicitly_ret_unit() {
    println!("This function returns unit by default");
}

Unit type
5.ğŸŒŸğŸŒŸ
se std::mem::size_of_val;

fn main() {
    let unit = ();
    assert_eq!(size_of_val(&unit), 0); // unit Ğ·Ğ°Ğ¹Ğ¼Ğ°Ñ” 0 Ğ±Ğ°Ğ¹Ñ‚

    println!("Success!");
}

6.ğŸŒŸğŸŒŸ What's the size of the unit type?

fn main() {
    print_char('R');
    check_bool(true);
    let u = return_unit();
    assert_eq!(u, ());
    println!("Success!");
}

// char
fn print_char(c: char) {
    println!("{}", c);
}

// bool
fn check_bool(b: bool) {
    if b {
        println!("It's true!");
    } else {
        println!("It's false!");
    }
}

// unit
fn return_unit() -> () {
    println!("Returning unit");
}


4.3 Statements and Expressions
Examples
fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // This expression will be assigned to `y`
        x_cube + x_squared + x
    };

    let z = {
        // The semicolon suppresses this expression and `()` is assigned to `z`
        2 * x;
    };

    println!("x is {:?}", x);
    println!("y is {:?}", y);
    println!("z is {:?}", z);
}

Exercises
1.ğŸŒŸğŸŒŸ
fn main() {
    let v = {
        let mut x = 1;
        x += 2; // statement
        x        // expression â€” Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ” x
    };

    assert_eq!(v, 3);

    println!("Success!");
}

2.ğŸŒŸ
fn main() {
    let v = {
        let x = 3; // statement
        x           // expression Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ” 3
    };

    assert!(v == 3);

    println!("Success!");
}

3.ğŸŒŸ
fn main() {
    let s = sum(1, 2);
    assert_eq!(s, 3);

    println!("Success!");
}

fn sum(x: i32, y: i32) -> i32 {
    x + y  // Ğ¾ÑÑ‚Ğ°Ğ½Ğ½Ñ–Ğ¹ Ñ€ÑĞ´Ğ¾Ğº Ğ±ĞµĞ· ; â†’ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ” Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—
}


4.4 Functions
1.ğŸŒŸğŸŒŸğŸŒŸ

fn main() {
    let (x, y) = (1, 2);
    let s = sum(x, y);

    assert_eq!(s, 3);
    println!("Success!");
}

fn sum(x: i32, y: i32) -> i32 {
    x + y
}

2.ğŸŒŸ
fn main() {
    print();
}

fn print() {
    println!("Success!");
}

3.ğŸŒŸğŸŒŸğŸŒŸ
fn return_number() -> i32 {
    42
}

fn main() {
    let x = return_number(); // ok
    println!("{}", x);
}


Diverging functions
Diverging functions never return to the caller, so they may be used in places where a value of any type is expected.

4.ğŸŒŸğŸŒŸ
fn main() {
    // ĞŸÑ€Ğ¸ tp == 1, Ğ¼Ğ°Ñ”Ğ¼Ğ¾ Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ñ‚Ğ¸ Some(42)
    println!("{:?}", get_option(1));
}

// Ğ¤ÑƒĞ½ĞºÑ†Ñ–Ñ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ” Option<i32> Ğ°Ğ±Ğ¾ Ğ½Ñ–ĞºĞ¾Ğ»Ğ¸ Ğ½Ğµ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ”
fn get_option(tp: u8) -> Option<i32> {
    match tp {
        1 => {
            return Some(42); // Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ”Ğ¼Ğ¾ Some Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ
        }
        _ => {
            // Ğ’Ğ¸ĞºĞ»Ğ¸ĞºĞ°Ñ”Ğ¼Ğ¾ Ğ´Ñ–Ğ²ĞµÑ€Ğ³ÑƒÑÑ‡Ñƒ Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ â€” Ğ²Ğ¾Ğ½Ğ° Ğ½Ñ–ĞºĞ¾Ğ»Ğ¸ Ğ½Ğµ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ”
            never_return_fn()
        }
    }
}

// Ğ†ĞœĞŸĞ›Ğ•ĞœĞ•ĞĞ¢ĞĞ¦Ğ†Ğ¯ never_return_fn() -> !
// Ğ’Ğ¸ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ±ÑƒĞ´ÑŒâ€‘ÑĞºĞ¸Ğ¹ Ğ· Ñ‚Ñ€ÑŒĞ¾Ñ… Ğ²Ğ°Ñ€Ñ–Ğ°Ğ½Ñ‚Ñ–Ğ²:

// 1. Ğ§ĞµÑ€ĞµĞ· panic!
fn never_return_fn() -> ! {
    panic!("This function never returns!");
}

// 2. Ğ§ĞµÑ€ĞµĞ· Ğ½ĞµÑĞºÑ–Ğ½Ñ‡ĞµĞ½Ğ½Ğ¸Ğ¹ Ñ†Ğ¸ĞºĞ»
/*
fn never_return_fn() -> ! {
    loop {}
}
*/

// 3. Ğ§ĞµÑ€ĞµĞ· unimplemented!() Ğ°Ğ±Ğ¾ todo!()
/*
fn never_return_fn() -> ! {
    unimplemented!()
}
*/

5.ğŸŒŸğŸŒŸ
fn main() {
    let b = false;

    let _v = match b {
        true => 1,
        false => {
            println!("Success!");
            panic!("we have no value for `false`, but we can panic");
        }
    };

    println!("Exercise Failed if printing out this line!");
}




